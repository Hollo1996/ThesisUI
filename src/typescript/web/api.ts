/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * DRP
 * This is the main server of QLM's DRP system
 *
 * OpenAPI spec version: 1.0.0
 * Contact: akos.hollo-szabo@qlndc.hu
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
import { Result } from "../data/web/result";
import { Objective } from "../data/web/objective";
import { Salesman } from "../data/web/salesman";
import { Setting } from "../data/web/setting";
import { Task } from "../data/web/task";
import { Gps } from "../data/web/gps";
import { Progress } from "../data/web/progress";
import { Edge } from "../data/web/edge";

const BASE_PATH = "https://waprom.drp".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name!: "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * LifecicleApi - fetch parameter creator
 * @export
 */
export const LifecicleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * clean data generated to prepare for the optimisation
         * @summary clean generated data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clean(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/clean`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * make one cycle of already started algorithm
         * @summary make one cycle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cycle(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/cycle`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * pause automated optimisation
         * @summary pause optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/pause`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * prepare seted up optimisation
         * @summary prepare optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepare(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/prepare`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * resume started optimisation
         * @summary resume optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/resume`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * start prepared optimisation
         * @summary start optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * make one iteration of already started algorithm
         * @summary make one iteration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        step(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/step`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * stop running optimisation
         * @summary stop optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecicleApi - functional programming interface
 * @export
 */
export const LifecicleApiFp = function (configuration?: Configuration) {
    return {
        /**
         * clean data generated to prepare for the optimisation
         * @summary clean generated data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clean(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).clean(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * make one cycle of already started algorithm
         * @summary make one cycle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cycle(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Result> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).cycle(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * pause automated optimisation
         * @summary pause optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).pause(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * prepare seted up optimisation
         * @summary prepare optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepare(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).prepare(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * resume started optimisation
         * @summary resume optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).resume(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * start prepared optimisation
         * @summary start optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).start(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * make one iteration of already started algorithm
         * @summary make one iteration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        step(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Result> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).step(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * stop running optimisation
         * @summary stop optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).stop(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LifecicleApi - factory interface
 * @export
 */
export const LifecicleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * clean data generated to prepare for the optimisation
         * @summary clean generated data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clean(options?: any) {
            return LifecicleApiFp(configuration).clean(options)(fetch, basePath);
        },
        /**
         * make one cycle of already started algorithm
         * @summary make one cycle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cycle(options?: any) {
            return LifecicleApiFp(configuration).cycle(options)(fetch, basePath);
        },
        /**
         * pause automated optimisation
         * @summary pause optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(options?: any) {
            return LifecicleApiFp(configuration).pause(options)(fetch, basePath);
        },
        /**
         * prepare seted up optimisation
         * @summary prepare optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepare(options?: any) {
            return LifecicleApiFp(configuration).prepare(options)(fetch, basePath);
        },
        /**
         * resume started optimisation
         * @summary resume optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(options?: any) {
            return LifecicleApiFp(configuration).resume(options)(fetch, basePath);
        },
        /**
         * start prepared optimisation
         * @summary start optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(options?: any) {
            return LifecicleApiFp(configuration).start(options)(fetch, basePath);
        },
        /**
         * make one iteration of already started algorithm
         * @summary make one iteration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        step(options?: any) {
            return LifecicleApiFp(configuration).step(options)(fetch, basePath);
        },
        /**
         * stop running optimisation
         * @summary stop optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(options?: any) {
            return LifecicleApiFp(configuration).stop(options)(fetch, basePath);
        },
    };
};

/**
 * LifecicleApi - object-oriented interface
 * @export
 * @class LifecicleApi
 * @extends {BaseAPI}
 */
export class LifecicleApi extends BaseAPI {
    /**
     * clean data generated to prepare for the optimisation
     * @summary clean generated data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public clean(options?: any) {
        return LifecicleApiFp(this.configuration).clean(options)(this.fetch, this.basePath);
    }

    /**
     * make one cycle of already started algorithm
     * @summary make one cycle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public cycle(options?: any) {
        return LifecicleApiFp(this.configuration).cycle(options)(this.fetch, this.basePath);
    }

    /**
     * pause automated optimisation
     * @summary pause optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public pause(options?: any) {
        return LifecicleApiFp(this.configuration).pause(options)(this.fetch, this.basePath);
    }

    /**
     * prepare seted up optimisation
     * @summary prepare optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public prepare(options?: any) {
        return LifecicleApiFp(this.configuration).prepare(options)(this.fetch, this.basePath);
    }

    /**
     * resume started optimisation
     * @summary resume optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public resume(options?: any) {
        return LifecicleApiFp(this.configuration).resume(options)(this.fetch, this.basePath);
    }

    /**
     * start prepared optimisation
     * @summary start optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public start(options?: any) {
        return LifecicleApiFp(this.configuration).start(options)(this.fetch, this.basePath);
    }

    /**
     * make one iteration of already started algorithm
     * @summary make one iteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public step(options?: any) {
        return LifecicleApiFp(this.configuration).step(options)(this.fetch, this.basePath);
    }

    /**
     * stop running optimisation
     * @summary stop optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public stop(options?: any) {
        return LifecicleApiFp(this.configuration).stop(options)(this.fetch, this.basePath);
    }

}

/**
 * SetupApi - fetch parameter creator
 * @export
 */
export const SetupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Give objectives of volume, weight, time with position for next optimisation runs
         * @summary Send objectives
         * @param {Objective} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addObjective(body: Objective, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling addObjective.');
            }
            const localVarPath = `/setup/objective`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Objective" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary Send salesman
         * @param {Salesman} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSalesman(body: Salesman, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling addSalesman.');
            }
            const localVarPath = `/setup/salesman`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Salesman" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define setting parameters for next optimisation run
         * @summary Define setting
         * @param {Setting} body Setting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineSetting(body: Setting, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling defineSetting.');
            }
            const localVarPath = `/setup/setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Setting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define task parameters for next optimisation run
         * @summary Define task
         * @param {Task} body Task parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineTask(body: Task, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling defineTask.');
            }
            const localVarPath = `/setup/task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Task" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available algorithms to choose from
         * @summary List available algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithms(options: any = {}): FetchArgs {
            const localVarPath = `/setup/setting/algorithm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List names of saved settings
         * @summary List names of settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettingsNames(options: any = {}): FetchArgs {
            const localVarPath = `/setup/setting/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List names of saved tasks
         * @summary List names of tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskNames(options: any = {}): FetchArgs {
            const localVarPath = `/setup/task/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load setting with a name maching the parameter
         * @summary Load setting
         * @param {string} body Setting name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSetting(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling loadSetting.');
            }
            const localVarPath = `/setup/setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load task with a name maching the parameter
         * @summary Load task
         * @param {string} body Task name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadTask(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling loadTask.');
            }
            const localVarPath = `/setup/task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete objective specified by name
         * @summary Delete objective
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeObjective(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling removeObjective.');
            }
            const localVarPath = `/setup/objective`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete salesman specified by name
         * @summary Delete salesman
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSalesman(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling removeSalesman.');
            }
            const localVarPath = `/setup/salesman`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save defined setting by name
         * @summary Save setting
         * @param {string} body Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSetting(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling saveSetting.');
            }
            const localVarPath = `/setup/setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save defined task by name
         * @summary Save task
         * @param {string} body Task name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling saveTask.');
            }
            const localVarPath = `/setup/task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupApi - functional programming interface
 * @export
 */
export const SetupApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Give objectives of volume, weight, time with position for next optimisation runs
         * @summary Send objectives
         * @param {Objective} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addObjective(body: Objective, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).addObjective(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary Send salesman
         * @param {Salesman} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSalesman(body: Salesman, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).addSalesman(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Define setting parameters for next optimisation run
         * @summary Define setting
         * @param {Setting} body Setting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineSetting(body: Setting, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).defineSetting(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Define task parameters for next optimisation run
         * @summary Define task
         * @param {Task} body Task parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineTask(body: Task, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).defineTask(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List available algorithms to choose from
         * @summary List available algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithms(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).listAlgorithms(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List names of saved settings
         * @summary List names of settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettingsNames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).listSettingsNames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List names of saved tasks
         * @summary List names of tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskNames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).listTaskNames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load setting with a name maching the parameter
         * @summary Load setting
         * @param {string} body Setting name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSetting(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Setting> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).loadSetting(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load task with a name maching the parameter
         * @summary Load task
         * @param {string} body Task name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadTask(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Task> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).loadTask(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete objective specified by name
         * @summary Delete objective
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeObjective(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).removeObjective(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete salesman specified by name
         * @summary Delete salesman
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSalesman(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).removeSalesman(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save defined setting by name
         * @summary Save setting
         * @param {string} body Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSetting(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).saveSetting(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save defined task by name
         * @summary Save task
         * @param {string} body Task name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).saveTask(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SetupApi - factory interface
 * @export
 */
export const SetupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Give objectives of volume, weight, time with position for next optimisation runs
         * @summary Send objectives
         * @param {Objective} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addObjective(body: Objective, options?: any) {
            return SetupApiFp(configuration).addObjective(body, options)(fetch, basePath);
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary Send salesman
         * @param {Salesman} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSalesman(body: Salesman, options?: any) {
            return SetupApiFp(configuration).addSalesman(body, options)(fetch, basePath);
        },
        /**
         * Define setting parameters for next optimisation run
         * @summary Define setting
         * @param {Setting} body Setting parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineSetting(body: Setting, options?: any) {
            return SetupApiFp(configuration).defineSetting(body, options)(fetch, basePath);
        },
        /**
         * Define task parameters for next optimisation run
         * @summary Define task
         * @param {Task} body Task parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineTask(body: Task, options?: any) {
            return SetupApiFp(configuration).defineTask(body, options)(fetch, basePath);
        },
        /**
         * List available algorithms to choose from
         * @summary List available algorithms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlgorithms(options?: any) {
            return SetupApiFp(configuration).listAlgorithms(options)(fetch, basePath);
        },
        /**
         * List names of saved settings
         * @summary List names of settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettingsNames(options?: any) {
            return SetupApiFp(configuration).listSettingsNames(options)(fetch, basePath);
        },
        /**
         * List names of saved tasks
         * @summary List names of tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskNames(options?: any) {
            return SetupApiFp(configuration).listTaskNames(options)(fetch, basePath);
        },
        /**
         * Load setting with a name maching the parameter
         * @summary Load setting
         * @param {string} body Setting name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSetting(body: string, options?: any) {
            return SetupApiFp(configuration).loadSetting(body, options)(fetch, basePath);
        },
        /**
         * Load task with a name maching the parameter
         * @summary Load task
         * @param {string} body Task name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadTask(body: string, options?: any) {
            return SetupApiFp(configuration).loadTask(body, options)(fetch, basePath);
        },
        /**
         * delete objective specified by name
         * @summary Delete objective
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeObjective(body: string, options?: any) {
            return SetupApiFp(configuration).removeObjective(body, options)(fetch, basePath);
        },
        /**
         * delete salesman specified by name
         * @summary Delete salesman
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSalesman(body: string, options?: any) {
            return SetupApiFp(configuration).removeSalesman(body, options)(fetch, basePath);
        },
        /**
         * Save defined setting by name
         * @summary Save setting
         * @param {string} body Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSetting(body: string, options?: any) {
            return SetupApiFp(configuration).saveSetting(body, options)(fetch, basePath);
        },
        /**
         * Save defined task by name
         * @summary Save task
         * @param {string} body Task name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask(body: string, options?: any) {
            return SetupApiFp(configuration).saveTask(body, options)(fetch, basePath);
        },
    };
};

/**
 * SetupApi - object-oriented interface
 * @export
 * @class SetupApi
 * @extends {BaseAPI}
 */
export class SetupApi extends BaseAPI {
    /**
     * Give objectives of volume, weight, time with position for next optimisation runs
     * @summary Send objectives
     * @param {Objective} body Setup parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public addObjective(body: Objective, options?: any) {
        return SetupApiFp(this.configuration).addObjective(body, options)(this.fetch, this.basePath);
    }

    /**
     * Give salesman of volume, weight, time with position for next optimisation runs
     * @summary Send salesman
     * @param {Salesman} body Setup parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public addSalesman(body: Salesman, options?: any) {
        return SetupApiFp(this.configuration).addSalesman(body, options)(this.fetch, this.basePath);
    }

    /**
     * Define setting parameters for next optimisation run
     * @summary Define setting
     * @param {Setting} body Setting parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public defineSetting(body: Setting, options?: any) {
        return SetupApiFp(this.configuration).defineSetting(body, options)(this.fetch, this.basePath);
    }

    /**
     * Define task parameters for next optimisation run
     * @summary Define task
     * @param {Task} body Task parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public defineTask(body: Task, options?: any) {
        return SetupApiFp(this.configuration).defineTask(body, options)(this.fetch, this.basePath);
    }

    /**
     * List available algorithms to choose from
     * @summary List available algorithms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public listAlgorithms(options?: any) {
        return SetupApiFp(this.configuration).listAlgorithms(options)(this.fetch, this.basePath);
    }

    /**
     * List names of saved settings
     * @summary List names of settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public listSettingsNames(options?: any) {
        return SetupApiFp(this.configuration).listSettingsNames(options)(this.fetch, this.basePath);
    }

    /**
     * List names of saved tasks
     * @summary List names of tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public listTaskNames(options?: any) {
        return SetupApiFp(this.configuration).listTaskNames(options)(this.fetch, this.basePath);
    }

    /**
     * Load setting with a name maching the parameter
     * @summary Load setting
     * @param {string} body Setting name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public loadSetting(body: string, options?: any) {
        return SetupApiFp(this.configuration).loadSetting(body, options)(this.fetch, this.basePath);
    }

    /**
     * Load task with a name maching the parameter
     * @summary Load task
     * @param {string} body Task name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public loadTask(body: string, options?: any) {
        return SetupApiFp(this.configuration).loadTask(body, options)(this.fetch, this.basePath);
    }

    /**
     * delete objective specified by name
     * @summary Delete objective
     * @param {string} body identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public removeObjective(body: string, options?: any) {
        return SetupApiFp(this.configuration).removeObjective(body, options)(this.fetch, this.basePath);
    }

    /**
     * delete salesman specified by name
     * @summary Delete salesman
     * @param {string} body identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public removeSalesman(body: string, options?: any) {
        return SetupApiFp(this.configuration).removeSalesman(body, options)(this.fetch, this.basePath);
    }

    /**
     * Save defined setting by name
     * @summary Save setting
     * @param {string} body Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public saveSetting(body: string, options?: any) {
        return SetupApiFp(this.configuration).saveSetting(body, options)(this.fetch, this.basePath);
    }

    /**
     * Save defined task by name
     * @summary Save task
     * @param {string} body Task name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public saveTask(body: string, options?: any) {
        return SetupApiFp(this.configuration).saveTask(body, options)(this.fetch, this.basePath);
    }

}

/**
 * UpdateApi - fetch parameter creator
 * @export
 */
export const UpdateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get runtime and iteration of running algorithm
         * @summary get run progress of running algorithm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgress(options: any = {}): FetchArgs {
            const localVarPath = `/update/progress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get actual result of startes algorithm
         * @summary get actual result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(options: any = {}): FetchArgs {
            const localVarPath = `/update/result`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get rout between two locations specified by GPS coordinates
         * @summary get rout between locations
         * @param {number} fromLat lattitude of GPS coords of source location
         * @param {number} fromLong longitude of GPS coords of source location
         * @param {number} toLat lattitude of GPS coords of target location
         * @param {number} toLong longitude of GPS coords of target location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options: any = {}): FetchArgs {
            // verify required parameter 'fromLat' is not null or undefined
            if (fromLat === null || fromLat === undefined) {
                throw new RequiredError('fromLat', 'Required parameter fromLat was null or undefined when calling getRoutBetween.');
            }
            // verify required parameter 'fromLong' is not null or undefined
            if (fromLong === null || fromLong === undefined) {
                throw new RequiredError('fromLong', 'Required parameter fromLong was null or undefined when calling getRoutBetween.');
            }
            // verify required parameter 'toLat' is not null or undefined
            if (toLat === null || toLat === undefined) {
                throw new RequiredError('toLat', 'Required parameter toLat was null or undefined when calling getRoutBetween.');
            }
            // verify required parameter 'toLong' is not null or undefined
            if (toLong === null || toLong === undefined) {
                throw new RequiredError('toLong', 'Required parameter toLong was null or undefined when calling getRoutBetween.');
            }
            const localVarPath = `/update/rout/{fromLat}/{fromLong}/{toLat}/{toLong}`
                .replace(`{${"fromLat"}}`, encodeURIComponent(String(fromLat)))
                .replace(`{${"fromLong"}}`, encodeURIComponent(String(fromLong)))
                .replace(`{${"toLat"}}`, encodeURIComponent(String(toLat)))
                .replace(`{${"toLong"}}`, encodeURIComponent(String(toLong)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter["Access-Control-Allow-Origin"] = "*"

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateApi - functional programming interface
 * @export
 */
export const UpdateApiFp = function (configuration?: Configuration) {
    return {
        /**
         * get runtime and iteration of running algorithm
         * @summary get run progress of running algorithm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgress(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Progress> {
            const localVarFetchArgs = UpdateApiFetchParamCreator(configuration).getProgress(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get actual result of startes algorithm
         * @summary get actual result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Result> {
            const localVarFetchArgs = UpdateApiFetchParamCreator(configuration).getResult(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get rout between two locations specified by GPS coordinates
         * @summary get rout between locations
         * @param {number} fromLat lattitude of GPS coords of source location
         * @param {number} fromLong longitude of GPS coords of source location
         * @param {number} toLat lattitude of GPS coords of target location
         * @param {number} toLong longitude of GPS coords of target location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Edge> {
            const localVarFetchArgs = UpdateApiFetchParamCreator(configuration).getRoutBetween(fromLat, fromLong, toLat, toLong, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UpdateApi - factory interface
 * @export
 */
export const UpdateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * get runtime and iteration of running algorithm
         * @summary get run progress of running algorithm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgress(options?: any) {
            return UpdateApiFp(configuration).getProgress(options)(fetch, basePath);
        },
        /**
         * get actual result of startes algorithm
         * @summary get actual result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(options?: any) {
            return UpdateApiFp(configuration).getResult(options)(fetch, basePath);
        },
        /**
         * get rout between two locations specified by GPS coordinates
         * @summary get rout between locations
         * @param {number} fromLat lattitude of GPS coords of source location
         * @param {number} fromLong longitude of GPS coords of source location
         * @param {number} toLat lattitude of GPS coords of target location
         * @param {number} toLong longitude of GPS coords of target location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options?: any) {
            return UpdateApiFp(configuration).getRoutBetween(fromLat, fromLong, toLat, toLong, options)(fetch, basePath);
        },
    };
};

/**
 * UpdateApi - object-oriented interface
 * @export
 * @class UpdateApi
 * @extends {BaseAPI}
 */
export class UpdateApi extends BaseAPI {
    /**
     * get runtime and iteration of running algorithm
     * @summary get run progress of running algorithm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateApi
     */
    public getProgress(options?: any) {
        return UpdateApiFp(this.configuration).getProgress(options)(this.fetch, this.basePath);
    }

    /**
     * get actual result of startes algorithm
     * @summary get actual result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateApi
     */
    public getResult(options?: any) {
        return UpdateApiFp(this.configuration).getResult(options)(this.fetch, this.basePath);
    }

    /**
     * get rout between two locations specified by GPS coordinates
     * @summary get rout between locations
     * @param {number} fromLat lattitude of GPS coords of source location
     * @param {number} fromLong longitude of GPS coords of source location
     * @param {number} toLat lattitude of GPS coords of target location
     * @param {number} toLong longitude of GPS coords of target location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateApi
     */
    public getRoutBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options?: any) {
        return UpdateApiFp(this.configuration).getRoutBetween(fromLat, fromLong, toLat, toLong, options)(this.fetch, this.basePath);
    }

}
