/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * DRP
 * This is the main server of QLM's DRP system
 *
 * OpenAPI spec version: 1.0.0
 * Contact: akos.hollo-szabo@qlndc.hu
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
import { GPS } from "../data/web/gps";
import { Objective } from "../data/web/objective";
import { Salesman } from "../data/web/salesman";
import { Setup } from "../data/web/setup";
import { State } from "../data/web/state";

export const BASE_PATH = "https://waprom.drp".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * LifecicleApi - fetch parameter creator
 * @export
 */
export const LifecicleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * clean data generated to prepare for the optimisation
         * @summary clean generated data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clean(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/clean`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * pause automated optimisation
         * @summary pause optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/pause`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * prepare seted up optimisation
         * @summary prepare optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepare(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/prepare`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * resume started optimisation
         * @summary resume optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/resume`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * start prepared optimisation
         * @summary start optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * stop running optimisation
         * @summary stop optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(options: any = {}): FetchArgs {
            const localVarPath = `/lifecycle/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecicleApi - functional programming interface
 * @export
 */
export const LifecicleApiFp = function (configuration?: Configuration) {
    return {
        /**
         * clean data generated to prepare for the optimisation
         * @summary clean generated data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clean(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).clean(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * pause automated optimisation
         * @summary pause optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).pause(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * prepare seted up optimisation
         * @summary prepare optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepare(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).prepare(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * resume started optimisation
         * @summary resume optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).resume(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * start prepared optimisation
         * @summary start optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).start(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * stop running optimisation
         * @summary stop optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LifecicleApiFetchParamCreator(configuration).stop(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LifecicleApi - factory interface
 * @export
 */
export const LifecicleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * clean data generated to prepare for the optimisation
         * @summary clean generated data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clean(options?: any) {
            return LifecicleApiFp(configuration).clean(options)(fetch, basePath);
        },
        /**
         * pause automated optimisation
         * @summary pause optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(options?: any) {
            return LifecicleApiFp(configuration).pause(options)(fetch, basePath);
        },
        /**
         * prepare seted up optimisation
         * @summary prepare optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepare(options?: any) {
            return LifecicleApiFp(configuration).prepare(options)(fetch, basePath);
        },
        /**
         * resume started optimisation
         * @summary resume optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resume(options?: any) {
            return LifecicleApiFp(configuration).resume(options)(fetch, basePath);
        },
        /**
         * start prepared optimisation
         * @summary start optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(options?: any) {
            return LifecicleApiFp(configuration).start(options)(fetch, basePath);
        },
        /**
         * stop running optimisation
         * @summary stop optimisation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stop(options?: any) {
            return LifecicleApiFp(configuration).stop(options)(fetch, basePath);
        },
    };
};

/**
 * LifecicleApi - object-oriented interface
 * @export
 * @class LifecicleApi
 * @extends {BaseAPI}
 */
export class LifecicleApi extends BaseAPI {
    /**
     * clean data generated to prepare for the optimisation
     * @summary clean generated data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public clean(options?: any) {
        return LifecicleApiFp(this.configuration).clean(options)(this.fetch, this.basePath);
    }

    /**
     * pause automated optimisation
     * @summary pause optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public pause(options?: any) {
        return LifecicleApiFp(this.configuration).pause(options)(this.fetch, this.basePath);
    }

    /**
     * prepare seted up optimisation
     * @summary prepare optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public prepare(options?: any) {
        return LifecicleApiFp(this.configuration).prepare(options)(this.fetch, this.basePath);
    }

    /**
     * resume started optimisation
     * @summary resume optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public resume(options?: any) {
        return LifecicleApiFp(this.configuration).resume(options)(this.fetch, this.basePath);
    }

    /**
     * start prepared optimisation
     * @summary start optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public start(options?: any) {
        return LifecicleApiFp(this.configuration).start(options)(this.fetch, this.basePath);
    }

    /**
     * stop running optimisation
     * @summary stop optimisation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecicleApi
     */
    public stop(options?: any) {
        return LifecicleApiFp(this.configuration).stop(options)(this.fetch, this.basePath);
    }

}

/**
 * SetupApi - fetch parameter creator
 * @export
 */
export const SetupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Give objectives of volume, weight, time with position for next optimisation runs
         * @summary Send objectives
         * @param {Objective} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addObjective(body: Objective, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling addObjective.');
            }
            const localVarPath = `/setup/objective`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Objective" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary Send salesman
         * @param {Salesman} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSalesman(body: Salesman, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling addSalesman.');
            }
            const localVarPath = `/setup/salesman`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Salesman" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define setup parameters for next optimisation run
         * @summary Define setup
         * @param {Setup} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineSetup(body: Setup, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling defineSetup.');
            }
            const localVarPath = `/setup/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Setup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary get state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getState(options: any = {}): FetchArgs {
            const localVarPath = `/setup/state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Defune setup parameters for next optimisation run
         * @summary Define setup
         * @param {string} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSetup(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling loadSetup.');
            }
            const localVarPath = `/setup/setup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary get state
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadState(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling loadState.');
            }
            const localVarPath = `/state/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete objective specified by name
         * @summary Delete objective
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeObjective(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling removeObjective.');
            }
            const localVarPath = `/setup/objective`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete salesman specified by name
         * @summary Delete salesman
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSalesman(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling removeSalesman.');
            }
            const localVarPath = `/setup/salesman`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save defined setup by name
         * @summary Save setup
         * @param {string} body Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSetup(body: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling saveSetup.');
            }
            const localVarPath = `/setup/save`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupApi - functional programming interface
 * @export
 */
export const SetupApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Give objectives of volume, weight, time with position for next optimisation runs
         * @summary Send objectives
         * @param {Objective} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addObjective(body: Objective, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).addObjective(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary Send salesman
         * @param {Salesman} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSalesman(body: Salesman, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).addSalesman(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Define setup parameters for next optimisation run
         * @summary Define setup
         * @param {Setup} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineSetup(body: Setup, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).defineSetup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary get state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getState(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).getState(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Defune setup parameters for next optimisation run
         * @summary Define setup
         * @param {string} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSetup(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Setup> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).loadSetup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary get state
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadState(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<State> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).loadState(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete objective specified by name
         * @summary Delete objective
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeObjective(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).removeObjective(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete salesman specified by name
         * @summary Delete salesman
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSalesman(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).removeSalesman(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save defined setup by name
         * @summary Save setup
         * @param {string} body Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSetup(body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SetupApiFetchParamCreator(configuration).saveSetup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SetupApi - factory interface
 * @export
 */
export const SetupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Give objectives of volume, weight, time with position for next optimisation runs
         * @summary Send objectives
         * @param {Objective} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addObjective(body: Objective, options?: any) {
            return SetupApiFp(configuration).addObjective(body, options)(fetch, basePath);
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary Send salesman
         * @param {Salesman} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSalesman(body: Salesman, options?: any) {
            return SetupApiFp(configuration).addSalesman(body, options)(fetch, basePath);
        },
        /**
         * Define setup parameters for next optimisation run
         * @summary Define setup
         * @param {Setup} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineSetup(body: Setup, options?: any) {
            return SetupApiFp(configuration).defineSetup(body, options)(fetch, basePath);
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary get state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getState(options?: any) {
            return SetupApiFp(configuration).getState(options)(fetch, basePath);
        },
        /**
         * Defune setup parameters for next optimisation run
         * @summary Define setup
         * @param {string} body Setup parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadSetup(body: string, options?: any) {
            return SetupApiFp(configuration).loadSetup(body, options)(fetch, basePath);
        },
        /**
         * Give salesman of volume, weight, time with position for next optimisation runs
         * @summary get state
         * @param {string} name Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadState(name: string, options?: any) {
            return SetupApiFp(configuration).loadState(name, options)(fetch, basePath);
        },
        /**
         * delete objective specified by name
         * @summary Delete objective
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeObjective(body: string, options?: any) {
            return SetupApiFp(configuration).removeObjective(body, options)(fetch, basePath);
        },
        /**
         * delete salesman specified by name
         * @summary Delete salesman
         * @param {string} body identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSalesman(body: string, options?: any) {
            return SetupApiFp(configuration).removeSalesman(body, options)(fetch, basePath);
        },
        /**
         * Save defined setup by name
         * @summary Save setup
         * @param {string} body Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSetup(body: string, options?: any) {
            return SetupApiFp(configuration).saveSetup(body, options)(fetch, basePath);
        },
    };
};

/**
 * SetupApi - object-oriented interface
 * @export
 * @class SetupApi
 * @extends {BaseAPI}
 */
export class SetupApi extends BaseAPI {
    /**
     * Give objectives of volume, weight, time with position for next optimisation runs
     * @summary Send objectives
     * @param {Objective} body Setup parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public addObjective(body: Objective, options?: any) {
        return SetupApiFp(this.configuration).addObjective(body, options)(this.fetch, this.basePath);
    }

    /**
     * Give salesman of volume, weight, time with position for next optimisation runs
     * @summary Send salesman
     * @param {Salesman} body Setup parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public addSalesman(body: Salesman, options?: any) {
        return SetupApiFp(this.configuration).addSalesman(body, options)(this.fetch, this.basePath);
    }

    /**
     * Define setup parameters for next optimisation run
     * @summary Define setup
     * @param {Setup} body Setup parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public defineSetup(body: Setup, options?: any) {
        return SetupApiFp(this.configuration).defineSetup(body, options)(this.fetch, this.basePath);
    }

    /**
     * Give salesman of volume, weight, time with position for next optimisation runs
     * @summary get state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public getState(options?: any) {
        return SetupApiFp(this.configuration).getState(options)(this.fetch, this.basePath);
    }

    /**
     * Defune setup parameters for next optimisation run
     * @summary Define setup
     * @param {string} body Setup parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public loadSetup(body: string, options?: any) {
        return SetupApiFp(this.configuration).loadSetup(body, options)(this.fetch, this.basePath);
    }

    /**
     * Give salesman of volume, weight, time with position for next optimisation runs
     * @summary get state
     * @param {string} name Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public loadState(name: string, options?: any) {
        return SetupApiFp(this.configuration).loadState(name, options)(this.fetch, this.basePath);
    }

    /**
     * delete objective specified by name
     * @summary Delete objective
     * @param {string} body identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public removeObjective(body: string, options?: any) {
        return SetupApiFp(this.configuration).removeObjective(body, options)(this.fetch, this.basePath);
    }

    /**
     * delete salesman specified by name
     * @summary Delete salesman
     * @param {string} body identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public removeSalesman(body: string, options?: any) {
        return SetupApiFp(this.configuration).removeSalesman(body, options)(this.fetch, this.basePath);
    }

    /**
     * Save defined setup by name
     * @summary Save setup
     * @param {string} body Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupApi
     */
    public saveSetup(body: string, options?: any) {
        return SetupApiFp(this.configuration).saveSetup(body, options)(this.fetch, this.basePath);
    }

}

/**
 * UpdateApi - fetch parameter creator
 * @export
 */
export const UpdateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get time of best plan for actual transport
         * @summary get time of best result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestCost(options: any = {}): FetchArgs {
            const localVarPath = `/optimisation/bestCost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get best plan for actual transport
         * @summary get best result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestResult(options: any = {}): FetchArgs {
            const localVarPath = `/optimisation/best`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get best plan for actual transport
         * @summary get root between locations
         * @param {number} fromLat lattitude of GPS coords of source location
         * @param {number} fromLong longitude of GPS coords of source location
         * @param {number} toLat lattitude of GPS coords of target location
         * @param {number} toLong longitude of GPS coords of target location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options: any = {}): FetchArgs {
            // verify required parameter 'fromLat' is not null or undefined
            if (fromLat === null || fromLat === undefined) {
                throw new RequiredError('fromLat', 'Required parameter fromLat was null or undefined when calling getRootBetween.');
            }
            // verify required parameter 'fromLong' is not null or undefined
            if (fromLong === null || fromLong === undefined) {
                throw new RequiredError('fromLong', 'Required parameter fromLong was null or undefined when calling getRootBetween.');
            }
            // verify required parameter 'toLat' is not null or undefined
            if (toLat === null || toLat === undefined) {
                throw new RequiredError('toLat', 'Required parameter toLat was null or undefined when calling getRootBetween.');
            }
            // verify required parameter 'toLong' is not null or undefined
            if (toLong === null || toLong === undefined) {
                throw new RequiredError('toLong', 'Required parameter toLong was null or undefined when calling getRootBetween.');
            }
            const localVarPath = `/optimisation/root/{fromLat}/{fromLong}/{toLat}/{toLong}`
                .replace(`{${"fromLat"}}`, encodeURIComponent(String(fromLat)))
                .replace(`{${"fromLong"}}`, encodeURIComponent(String(fromLong)))
                .replace(`{${"toLat"}}`, encodeURIComponent(String(toLat)))
                .replace(`{${"toLong"}}`, encodeURIComponent(String(toLong)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateApi - functional programming interface
 * @export
 */
export const UpdateApiFp = function (configuration?: Configuration) {
    return {
        /**
         * get time of best plan for actual transport
         * @summary get time of best result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestCost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = UpdateApiFetchParamCreator(configuration).getBestCost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get best plan for actual transport
         * @summary get best result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestResult(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GPS>> {
            const localVarFetchArgs = UpdateApiFetchParamCreator(configuration).getBestResult(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get best plan for actual transport
         * @summary get root between locations
         * @param {number} fromLat lattitude of GPS coords of source location
         * @param {number} fromLong longitude of GPS coords of source location
         * @param {number} toLat lattitude of GPS coords of target location
         * @param {number} toLong longitude of GPS coords of target location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Array<number>>> {
            const localVarFetchArgs = UpdateApiFetchParamCreator(configuration).getRootBetween(fromLat, fromLong, toLat, toLong, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UpdateApi - factory interface
 * @export
 */
export const UpdateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * get time of best plan for actual transport
         * @summary get time of best result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestCost(options?: any) {
            return UpdateApiFp(configuration).getBestCost(options)(fetch, basePath);
        },
        /**
         * get best plan for actual transport
         * @summary get best result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBestResult(options?: any) {
            return UpdateApiFp(configuration).getBestResult(options)(fetch, basePath);
        },
        /**
         * get best plan for actual transport
         * @summary get root between locations
         * @param {number} fromLat lattitude of GPS coords of source location
         * @param {number} fromLong longitude of GPS coords of source location
         * @param {number} toLat lattitude of GPS coords of target location
         * @param {number} toLong longitude of GPS coords of target location
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options?: any) {
            return UpdateApiFp(configuration).getRootBetween(fromLat, fromLong, toLat, toLong, options)(fetch, basePath);
        },
    };
};

/**
 * UpdateApi - object-oriented interface
 * @export
 * @class UpdateApi
 * @extends {BaseAPI}
 */
export class UpdateApi extends BaseAPI {
    /**
     * get time of best plan for actual transport
     * @summary get time of best result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateApi
     */
    public getBestCost(options?: any) {
        return UpdateApiFp(this.configuration).getBestCost(options)(this.fetch, this.basePath);
    }

    /**
     * get best plan for actual transport
     * @summary get best result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateApi
     */
    public getBestResult(options?: any) {
        return UpdateApiFp(this.configuration).getBestResult(options)(this.fetch, this.basePath);
    }

    /**
     * get best plan for actual transport
     * @summary get root between locations
     * @param {number} fromLat lattitude of GPS coords of source location
     * @param {number} fromLong longitude of GPS coords of source location
     * @param {number} toLat lattitude of GPS coords of target location
     * @param {number} toLong longitude of GPS coords of target location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateApi
     */
    public getRootBetween(fromLat: number, fromLong: number, toLat: number, toLong: number, options?: any) {
        return UpdateApiFp(this.configuration).getRootBetween(fromLat, fromLong, toLat, toLong, options)(this.fetch, this.basePath);
    }

}

